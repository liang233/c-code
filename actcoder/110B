A,B:略
C:题目要求把一个字符串转变为另一个字符串，把两个字母对应的相交换,可以操作n次。
我并没有看懂题目要求，比如先a和b交换,再a和c交换，这样是不是可以？我的做法这样是可以的，但也1A了。
反正就换来换去嘛，不变的是字符的个数，只不过从a变成b了，排序过后的还是一样的嘛，所以两个字符串统计一下a到z的字符个数，排个序分别比较一下就行了。
D:数学题，还是看答案吧，看了答案还是比较好理解的。
n个数的和为m，寻找方案数,对1e9+7取模,(1,6)和（6,1）算两种
方法：对m进行唯一分解定理
m=a1^p1+a2^p2+...;其中a为质数
然后题目意思是 b1*b2*...*bn=m
然后很显然我们对每个质数分别处理，就拿a1为例，b1,b2,..bn 这n个数中要分p1.
这就是组合数学中组合的问题啊:
n个盒子分m个苹果，盒子可以为空，问有多少种分法（苹果是相同的，盒子是不同的）
等价于n个盒子分n+m个苹果，盒子至少分一个,....
然后n+m-1个空格取n-1个 即C(n+m-1,n-1)
然后回到我们这个环境中，个数为C（p1+n-1，n-1）
然后我们需要把每一个质数产生的组合数相乘起来。取模操作在每一个步骤中都有涉及。
复杂度我也说不大清，题解说是单个数唯一分解那里sqrt(M)，但我感觉貌似没那么大吧，反正不大了，不管了。


数学题我代码不是很熟练，简单的再写一下吧
用到的 
1.快速幂
2.1e9+7为质数，直接费马大定理逆元
ll inv(ll a,ll  mod)
{
	return quickpow(a,mod-2,mod);
}
3.阶乘预处理
void init()
{
   fac[0]=1;
   for(ll i=1;i<man;i++)
     fac[i]=(fac[i-1]*i)%mod;
}
4.组合数计算
ll Cal(ll n,ll m,ll mod)
{
    ll a=fac[n];
	ll b=(fac[m]*fac[n-m])%mod;
	return (a*inv(b,mod))%mod;
}
5.单个数唯一分解
map<ll,ll> prime_dection(ll x)
{
    map<ll,ll> res;
    for(ll i=2;i*i<=x;i++)
    {
        while(x%i==0)
        {
            ++res[i];
            x/=i;
        }
    }
    if(x!=1) res[x]++;
    return res;
}

基本就用到这些吧。
code:  https://pastebin.com/0c53p2ks

补充:如果题目改一改呢，把（1,6）和（6,1）算一个呢，那就不能用组合数来解了，可以用递归来解决
f(n,m)=f(n-m,m)+f(n,m-1）  按每一个都有数和至少有一个为0这两类进行分类





