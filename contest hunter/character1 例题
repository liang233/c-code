1.a^b 快速幂(a,b,p在10^9之内)
code:ll quick_mod(ll a,ll b,ll p)
{
    ll ans=1%p;
    for(;b;b>>=1)
    {
        if(b&1) ans=(ll)ans*a%p;
        a=(ll)a*a%p;
    }
    return ans;
}
2.64位整数乘法
code：
ll big_mul(ll a,ll b,ll p)
{
    ll ans=0;
    for(;b;b>>=1)
    {
        if(b&1) ans=(ans+a)%p;
        a=a*2%p;
    }
    return ans;
}
ll o_mul(ll a,ll b,ll p)
{
    a%=p;
    b%=p;
    ll c=(long double)a*b/p;
    ll  ans=a*b-c*p;
    if(ans<0)
        ans+=p;
    if(ans>p)
        ans-=p;
    return ans;
}
两种思路，一种类似快速幂的方式，将b进行二进制分解，第二种用a*b%p=a*b-[a*b/p]*p公式来计算。
3.最短Hamilton路径
Hamilton路径指从 0 到 n-1 不重不漏地经过每个点恰好一次
这道题利用的二进制状态压缩，定义状态为dp[p][i]表示点经过对应二进制状态为p，目前点处于点i的最短路径。
转移方程为dp[p][i]=min(dp[p^(1<<i)][j]+a[i][j])
边界条件为dp[1][0]=0;
memset(dp,0x3f,sizeof(dp));
dp[1][0]=0;
for(int p=1;p<(1<<n);p++)
    for(int i=0;i<n;i++) if((p>>i)&&1)
       for(int j=0;j<n;j++) if((p>>j)&&1)
       {
          dp[p][i]=min(dp[p][i],dp[p^(1<<i)][j]+a[i][j]);
       }
 cout<<dp[(1<<n)-1][n-1]<<endl;
 4.Islands and Bridges  poj2288 
 这道题是扩展题目，与上面那题比较类似，定义状态为dp[p][i][j]为点经过对应二进制状态为p，目前点处于点i，前一个点为j的最短路径。
 并且要统计最大路径的数量，定义ways[p][i][j]为点经过对应二进制状态为p，目前点处于点i，前一个点为j的最大路径的数量。
 路径的来源有三部分，第一部分边的长度，这个如果存在，是固定的，每个边都会走一遍，第二部分和第三部分需要统计
 转移方程：dp[p][i][j]=min(dp[p^(1<<i)][j][k]+a[i]*a[j]+(d[i][k]?a[i]*a[j]*a[k]:0))
          ways[p][i][j]+=(=)dp[p^(1<<i)][j][k];
 初始化：dp[p][i][j]定义为-1，然后分别进行枚举两个相邻的点，作为开始端,初始化dp和ways数组
 trick点:n==1时处理
 隔了几个小时，又写了一遍，写了好几次才ac..
 code: https://pastebin.com/FFNELjmS
 5.费解的开关
 题意：6次操作以内将全部0变成全部1，问是否可行？
 这道题也是不错的一道题，思路比较巧妙，前一行处理完固定后，如果还为1，那必须对下一行对应的数进行处理，也就是第一行先进行暴力预处理，
 后面的情况都是唯一的，只需要判别一下最后一行是否都为1和是否6步以内完成。
 code：https://pastebin.com/ymD3eAnM
 6.Strange Towers of Hanoi POJ - 1958
 递归题，不过这道题也是很有意思的一道题，n个盘子，4个塔，将A的n个盘子搬到D上最少需要多少次数。
 题意解释的很清楚了，先从A搬k个到B，再从A搬n-k个到D，再从B搬k个到C，
 然后我们看一下,先从A搬k个到B，再从B搬k个到C这两步可以认为是3个塔是空的，也是4个塔的操作
 再从A搬n-k个到D，是3个塔的操作。
 所以我们可以先考虑下3个塔的操作，3个塔，分别这样思考 A把n-1个盘子给B，然后把1个盘子给C，然后B给c n-1个盘子，d[n]=2*d[n-1]+1;
 然后我们可以得到4个塔的方程 f[n]=min(2*f[k]+d[n-k])
 
 

