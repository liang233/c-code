P1008 三连击
code:
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int t[10];
string c[3];
int main()
{
    for(int x=123;x<333;x++)
    {
      memset(t,0,sizeof(t));
      int a=x*2;
      int b=x*3;
      c[0]=to_string(x);
      c[1]=to_string(a);
      c[2]=to_string(b);
      int f=1;
      for(int i=0;i<3;i++)
      {
          for(int j=0;j<3;j++)
          {
              t[c[i][j]-'0']++;
              if(t[c[i][j]-'0']>1||c[i][j]=='0')
              {
                  f=0;
                  break;
              }
          }
          if(f==0)
          break;
      }
      if(f)
      {
          printf("%d %d %d\n",x,a,b);
      }
    }
}
P1980 计数问题 （P2602 数字计数 ）
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll r,l;
int k;
ll p[13]; //i的10次方
ll res[13];//记忆化搜索answer
ll gg[13];//  后缀数字
ll val[13];// 输入

void init()
{
   p[0]=1;
   for(int i=1;i<13;i++)
     p[i]=p[i-1]*10;
}

ll dfs(int pos,bool lead,bool limit)//不是每个题都要判断前导零
{
    //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了
    if(pos==0) return 0;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */
    //第二个就是记忆化(在此前可能不同题目还能有一些剪枝)
    if(!limit && !lead && res[pos]!=-1) return res[pos];
    /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/
    int up=limit?val[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了
    ll ans=0;
    //开始计数
    for(int i=0;i<=up;i++)//枚举，然后把不同情况的个数加到ans就可以了
    {
        if(!(lead && i==0)&& i==k)
        {
            if(limit && i==val[pos])
             ans+=gg[pos-1]+1;
             else
             ans+=p[pos-1];
        }
        
        ans+=dfs(pos-1,lead && i==0,limit && i==val[pos]); //最后两个变量传参都是这样写的
        /*这里还算比较灵活，不过做几个题就觉得这里也是套路了
        大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论
        去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目
        要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类，
        前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/
    }
    //计算完，记录状态
    if(!limit && !lead) res[pos]=ans;
    /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/
    return ans;
}

ll solve(ll x)
{
    memset(res,-1,sizeof(res));
    int len=0;
    while(x)
    {
        val[++len]=x%10;
        x/=10;
        gg[len]=gg[len-1]+val[len]*p[len-1];
    }
    return dfs(len,1,1);
}
int main()
{
    cin>>l>>r;
    init();
    for(int i=0;i<=9;i++){
    k=i;
    if(i==0) cout<<solve(r)-solve(l-1);
    else
    cout<<" "<<solve(r)-solve(l-1);
    }
    cout<<endl;
}
